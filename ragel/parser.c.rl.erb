#include <stdio.h>
#include <string.h>
#include <ruby.h>

%%{
  machine parser;
  
  action begin_content {
  }
  
  action begin_pystring {
  }
  
  action start_pystring {
  }
  
  action start_line {
  }
  
  action end_line {
  }
  
  action store_feature_content {
    rb_funcall(listener, rb_intern("feature"), 0);
    printf(" feature body found:  ");
    fwrite( bodys, 1, bodye - bodys, stdout );
    printf("\n");
  }
  
  action store_background_content {
    rb_funcall(listener, rb_intern("background"), 0);
  }
  
  action store_scenario_content {
    rb_funcall(listener, rb_intern("scenario"), 0);
    printf(" scenario body found:  ");
    fwrite( bodys, 1, bodye - bodys, stdout );
    printf("\n");
  }
  
  action store_scenario_outline_content {
    rb_funcall(listener, rb_intern("scenario_outline"), 0);
    printf(" scenario body found:  ");
    fwrite( bodys, 1, bodye - bodys, stdout );
    printf("\n");
  }
  
  action store_examples_content {
    rb_funcall(listener, rb_intern("examples"), 0);
  }
  
  action store_step_content {
    rb_funcall(listener, rb_intern("step"), 0);
  }
  
  action store_comment_content {
    rb_funcall(listener, rb_intern("comment"), 0);
  }
  
  action store_tag_content {
    rb_funcall(listener, rb_intern("tag"), 0);
  }
  
  action store_pystring_content {
    rb_funcall(listener, rb_intern("pystring"), 0);
  }
  
  action inc_line_number {
  }
    
  action last_newline {
  }
  
  action start_keyword {
    ws = fpc;

    if (next_keyword_start != 0) {
      next_keyword_start = p-1;
    }
  }
  
  action end_keyword {
    we = fpc;
    bodys = fpc + 1;

    printf(" keyword found:  ");
    fwrite( ws, 1, we - ws, stdout );
    printf("\n");

    if (next_keyword_start != 0){
      p = next_keyword_start;
    }
    next_keyword_start = 0;
  }
  
  action next_keyword_start {
    bodye = fpc;

    if(next_keyword_start == 0) {
      next_keyword_start = fpc;
    }
  }
  
  action end_table {
    rb_funcall(listener, rb_intern("table"), 0);
  }
 
  action end_feature {
  }
  
  include parser_common "parser_common.<%= i18n_language %>.rl"; 
}%%

%% write data;

static VALUE mGherkin;
static VALUE mParser;
static VALUE cCParser;

static VALUE CParser_init(VALUE self, VALUE listener)
{
  rb_iv_set(self, "@listener", listener);
  return self;
}

#define MAXWORDS 2

static VALUE CParser_scan(VALUE self, VALUE text)
{
  int cs;
  int i = 0;

  char *ws;
  char *we;
  char *bodys;
  char *bodye;

  char *next_keyword_start = 0;

  char *p = RSTRING(text)->ptr;
  strcat(p, "\n%_FEATURE_END_%");
  char *pe = p + strlen(p);
  char *eof = pe;

  VALUE listener = rb_iv_get(self, "@listener");
  
  %%{
    write init;
    write exec;
  }%%
  
  return Qnil;
}

void Init_gherkin_parser() {
  mGherkin = rb_define_module("Gherkin");
  mParser = rb_define_module_under(mGherkin, "Parser");
  cCParser = rb_define_class_under(mParser, "CParser", rb_cObject);
  
  rb_define_method(cCParser, "initialize", CParser_init, 1);
  rb_define_method(cCParser, "scan", CParser_scan, 1);
}
